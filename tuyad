#!/usr/bin/env python
import tinytuya
import json
import time

import os
import struct
import colorsys
import subprocess
import threading
import numpy as np
from scipy.fft import fft
from flask import Flask, request, jsonify

DEVICES_FILE    = os.environ.get('DEVICES', os.path.expanduser('~/snapshot.json'))
XDG_RUNTIME_DIR = os.environ.get('XDG_RUNTIME_DIR',f'/run/user/{os.getuid()}')
AUDIO_TARGET    = os.environ.get('TUYA_MCP_AUDIO_TARGET', 'alsa_output.pci-0000_00_1b.0.analog-stereo.monitor')
devices = []

app = Flask(__name__)

def load_devices():
    global devices
    try:
        with open(DEVICES_FILE, 'r') as f:
            devices = json.load(f).get("devices", [])
        print("Devices loaded")
        return {"status": "success"}
    except FileNotFoundError:
        print(f"Error: {DEVICES_FILE} not found.")
        return {"status": "error", "message": f"Error: {DEVICES_FILE} not found."}
    except json.JSONDecodeError:
        print(f"Error: Invalid JSON format in {DEVICES_FILE}.")
        return {"status": "error", "message": f"Error: Invalid JSON format in {DEVICES_FILE}."}

def parse_audio(audio_data, freq_range):
    sample_rate = 44100
    n = len(audio_data)
    if n == 0:
        return (0, 0, 0)

    fft_data = np.fft.fft(audio_data)
    fft_abs = np.abs(fft_data[:n // 2])
    frequencies = np.fft.fftfreq(n, 1 / sample_rate)[:n // 2]

    # Extract only the assigned frequency range
    freq_mask = np.logical_and(frequencies >= freq_range[0], frequencies <= freq_range[1])
    freq_range_values = fft_abs[freq_mask]

    if not freq_range_values.size:
        return (0, 0, 0)

    # Find dominant frequency in the assigned range
    dominant_frequency_index = np.argmax(freq_range_values)
    dominant_frequency = frequencies[freq_mask][dominant_frequency_index]
    amplitude = freq_range_values[dominant_frequency_index]

    # Convert frequency and amplitude into HSV values
    hue = (dominant_frequency / freq_range[1]) * 360  
    saturation = min(amplitude / 10000, 1.0) * 1000  
    value = min(amplitude / 5000, 1.0) * 1000  

    return hue, saturation, value

color_names = {
    "red": (255, 0, 0),
    "green": (0, 255, 0),
    "blue": (0, 0, 255),
    "white": (255, 255, 255),
    "black": (0, 0, 0),
    "yellow": (255, 255, 0),
    "cyan": (0, 255, 255),
    "magenta": (255, 0, 255),
}

def parse_color(color_input):
    if isinstance(color_input, tuple) and len(color_input) == 3:
      return color_input
    if color_input.startswith('rgb(') and color_input.endswith(')'):
        try:
            parts = color_input[4:-1].split(',')
            r = int(parts[0].strip())
            g = int(parts[1].strip())
            b = int(parts[2].strip())
            return (r, g, b)
        except:
          return None
    elif color_input.startswith('#') and len(color_input) == 7:
        try:
            r = int(color_input[1:3], 16)
            g = int(color_input[3:5], 16)
            b = int(color_input[5:7], 16)
            return (r, g, b)
        except:
            return None
    elif color_input.lower() in color_names:
        return color_names[color_input.lower()]
    return None

def control_device(device, action, *args, function_name='', **kwargs):
    try:
        device_id = device['id']
        local_key = device['key']
        ip_address = device['ip']
        version = device["ver"]

        d = tinytuya.BulbDevice(device_id, ip_address, local_key)
        d.set_version(version)
        d.set_socketPersistent(True)

        function = getattr(d, function_name or action)
        function(*args, **kwargs)

    except Exception as e:
        print(f"Error controlling device {device.get('name', 'unknown')}: {e}")

def handle_action_over_devices(action, request, *args, function_name='', **kwargs):
    all_devices = request.json.get('all', False)
    device_name = request.json.get('device')

    if not all_devices and not device_name:
        return jsonify({"status": "error", "message": "device name must be provided"}), 400

    threads = []
    for device in devices:
        if device.get('name') == device_name or all_devices:
            thread = threading.Thread(target=control_device, args=(device, action, *args), kwargs={"function_name": function_name, **kwargs})
            thread.start()
            threads.append(thread)
            if not all_devices:
                return jsonify({"status": "success", "message": f"Device {device_name} {action}."})


    for thread in threads:
        thread.join()

    if all_devices:
        return jsonify({"status": "success", "message": f"All devices {action}."})

    return jsonify({"status": "error", "message": f"Device {device_name} not found"}), 404

@app.route('/list', methods=['GET'])
def device_list():
    return jsonify([{ 'name': d.get('name'), 'id': d['id'], 'ip': d['ip'], 'version': d["ver"] } for d in devices])

@app.route('/turn_on', methods=['POST'])
def turn_on():
    return handle_action_over_devices('turn_on', request)

@app.route('/turn_off', methods=['POST'])
def turn_off():
    return handle_action_over_devices('turn_off', request)

@app.route('/set_color', methods=['POST'])
def set_color():
    color_input = request.json.get('color')
    rgb = parse_color(color_input)
    if rgb and all(x is not None for x in rgb):
        return handle_action_over_devices('set_colour', request, *rgb)
    return jsonify({"status": "error", "message": "Invalid color format"}), 400

@app.route('/set_brightness', methods=['POST'])
def set_brightness():
    all_devices = request.json.get('all',False)
    device_name = request.json.get('device')
    brightness = request.json.get('brightness')
    if all_devices and not device_name or brightness is None:
        return jsonify({"status": "error", "message": "device and brightness must be provided"}), 400
    try:
        brightness = int(brightness)
    except ValueError:
        return jsonify({"status": "error", "message": "brightness must be an integer"}), 400
    if not (0 <= brightness <= 1000):
        return jsonify({"status": "error", "message": "brightness must be between 0 and 1000"}), 400
    handle_action_over_devices('set_brightness', request, brightness)
    return jsonify({"status": "success", "message": f"Device {device_name} brightness set to {brightness}"})

@app.route('/set_colourtemp', methods=['POST'])
def set_colourtemp():
    all_devices = request.json.get('all',False)
    device_name = request.json.get('device')
    colourtemp = request.json.get('colourtemp')
    if not all_devices and not device_name or colourtemp is None:
        return jsonify({"status": "error", "message": "device and colour temperature must be provided"}), 400
    try:
        colourtemp = int(colourtemp)
    except ValueError:
         return jsonify({"status": "error", "message": "colour temperature must be an integer"}), 400
    if not (0 <= colourtemp <= 1000):
        return jsonify({"status": "error", "message": "colour temperature must be between 0 and 1000"}), 400

    handle_action_over_devices('set_colourtemp', request, colourtemp)
    return jsonify({"status": "success", "message": f"Device {device_name} colour temperature set to {colourtemp}"})

@app.route('/set_mode', methods=['POST'])
def set_mode():
    all_devices = request.json.get('all',False)
    device_name = request.json.get('device')
    mode = request.json.get('mode')
    if not all_devices and not device_name or not mode:
        return jsonify({"status": "error", "message": "device and mode must be provided"}), 400
    if mode not in ["white", "colour", "scene", "music"]:
        return jsonify({"status": "error", "message": "mode must be white, colour, scene, or music"}), 400

    handle_action_over_devices('set_mode', request, mode)
    return jsonify({"status": "success", "message": f"Device {device_name} mode set to {mode}"})

@app.route('/music', methods=['POST'])
def music():
    all_devices = request.json.get('all', False)
    device_name = request.json.get('device')
    delay = request.json.get('delay', 0.1)

    if not all_devices and not device_name:
        return jsonify({"status": "error", "message": "device must be provided"}), 400
    try:
        delay = float(delay)
    except ValueError:
        return jsonify({"status": "error", "message": "delay must be a float"}), 400

    # Set the frequency range limits
    min_freq = 100   # Start of the frequency range
    max_freq = 2000  # End of the frequency range
    num_devices = len(devices)

    if num_devices == 0:
        return jsonify({"status": "error", "message": "No devices configured"}), 400

    # Divide the frequency range into equal bands for each device
    step = (max_freq - min_freq) // num_devices
    frequency_ranges = [(min_freq + i * step, min_freq + (i + 1) * step) for i in range(num_devices)]

    started_devices = []

    for i, device in enumerate(devices):
        if device.get('name') == device_name or all_devices:
            device_id = device['id']
            local_key = device['key']
            ip_address = device['ip']
            version = device["ver"]

            # Assign a specific frequency range dynamically
            freq_range = frequency_ranges[i]  

            try:
                d = tinytuya.BulbDevice(device_id, ip_address, local_key)
                d.set_version(version)
                d.set_socketPersistent(True)

                # Create a separate audio stream for each device
                process = subprocess.Popen(
                    ['parec', '-d', AUDIO_TARGET, '--format=s16le', '--rate=44100'], 
                    env={ 'XDG_RUNTIME_DIR': XDG_RUNTIME_DIR },
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE
                )

                def audio_process_thread(d, process, delay, freq_range):
                    try:
                        while True:
                            stdout = process.stdout.read(44100)
                            if not stdout:
                                d.set_hsv(0, 0, 0, nowait=True)
                                continue
                            audio_data = np.frombuffer(stdout, dtype=np.int16).astype(float)
                            hue, saturation, value = parse_audio(audio_data, freq_range)
                            d.set_hsv(hue / 360.0, saturation / 1000.0, value / 1000.0, nowait=True)
                            time.sleep(delay)
                    except Exception as e:
                        print(f"Error in audio processing thread: {e}")

                # Start a new thread for each device with its specific frequency range
                audio_thread = threading.Thread(target=audio_process_thread, args=(d, process, delay, freq_range), daemon=True)
                audio_thread.start()

                started_devices.append(f"{device['name']} ({freq_range[0]}-{freq_range[1]} Hz)")
            except Exception as e:
                return jsonify({"status": "error", "message": f"Error setting color for device {device_name}: {e}"}), 500

    if started_devices:
        return jsonify({"status": "success", "message": f"Music mode started for {', '.join(started_devices)}"})
    
    return jsonify({"status": "error", "message": "No matching devices found"}), 404

@app.route('/music_old', methods=['POST'])
def music_old():
    all_devices = request.json.get('all', False)
    device_name = request.json.get('device')
    delay = request.json.get('delay', 0.1)

    if not all_devices and not device_name:
        return jsonify({"status": "error", "message": "device must be provided"}), 400
    try:
        delay = float(delay)
    except ValueError:
        return jsonify({"status": "error", "message": "delay must be a float"}), 400

    started_devices = []

    for device in devices:
        if device.get('name') == device_name or all_devices:
            device_id = device['id']
            local_key = device['key']
            ip_address = device['ip']
            version = device["ver"]
            try:
                d = tinytuya.BulbDevice(device_id, ip_address, local_key)
                d.set_version(version)
                d.set_socketPersistent(True)

                # Each thread needs its own subprocess instance
                # FIXME maybe we could avoid the duplication keeping a buffer in the daemon
                process = subprocess.Popen(
                    ['parec', '-d', 'alsa_output.pci-0000_00_1b.0.analog-stereo.monitor', '--format=s16le', '--rate=44100'], 
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE
                )

                def audio_process_thread(d, process, delay):
                    try:
                        while True:
                            stdout = process.stdout.read(44100 * 2 * 1)
                            if not stdout:
                                d.set_hsv(0, 0, 0, nowait=True)
                                continue
                            audio_data = np.frombuffer(stdout, dtype=np.int16).astype(float)
                            hue, saturation, value = parse_audio(audio_data)
                            d.set_hsv(hue / 360.0, saturation / 1000.0, value / 1000.0, nowait=True)
                            time.sleep(delay)
                    except Exception as e:
                        print(f"Error in audio processing thread: {e}")

                # Start a new thread for each device
                audio_thread = threading.Thread(target=audio_process_thread, args=(d, process, delay), daemon=True)
                audio_thread.start()

                started_devices.append(device['name'])
            except Exception as e:
                return jsonify({"status": "error", "message": f"Error setting color for device {device_name}: {e}"}), 500

    if started_devices:
        return jsonify({"status": "success", "message": f"Music mode started for {', '.join(started_devices)}"})
    
    return jsonify({"status": "error", "message": "No matching devices found"}), 404


if __name__ == '__main__':
    if load_devices().get("status") == "success":
        print("Daemon started")
        app.run(host='0.0.0.0', port=5000, debug=True, use_reloader=False)
