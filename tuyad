#!/usr/bin/env python
import tinytuya
import json
import os
import struct
import subprocess
import asyncio
import aiofiles
import numpy as np
from scipy.fft import fft
from quart import Quart, request, jsonify
from colour import Color

import logging

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(message)s")

DEVICES_FILE = os.environ.get('DEVICES', os.path.expanduser('~/snapshot.json'))
XDG_RUNTIME_DIR = os.environ.get('XDG_RUNTIME_DIR', f'/run/user/{os.getuid()}')
AUDIO_TARGET = os.environ.get('TUYA_MCP_AUDIO_TARGET', 'alsa_output.pci-0000_00_1b.0.analog-stereo.monitor')
SAMPLE_RATE = 44100

devices = []
audio_tasks = []
app = Quart(__name__)

async def load_devices():
    global devices
    try:
        async with aiofiles.open(DEVICES_FILE, 'r') as f:
            data = await f.read()
            devices = json.loads(data).get("devices", [])
        logging.info("Devices loaded")
    except FileNotFoundError:
        logging.error(f"Error: {DEVICES_FILE} not found.")
        raise
    except json.JSONDecodeError:
        logging.error(f"Error: Invalid JSON format in {DEVICES_FILE}.")
        raise

async def control_device(device, action, *args, timeout=0.5, retries=1, **kwargs):
    try:
        device_id   = device['id'  ]
        device_name = device['name']
        local_key   = device['key' ]
        ip_address  = device['ip'  ]
        version     = device['ver' ]

        d = tinytuya.BulbDevice(
                device_id,
                ip_address,
                local_key,
                connection_retry_limit=retries,
                connection_timeout=timeout)
        d.set_version(version)
        function = getattr(d, action)
        logging.info(f"Executing {action} on {device_name}: {args} {kwargs}")
        function(*args, **kwargs)
        logging.info(f"Executed {action} on {device_name}")
    except Exception as e:
        logging.error(f"Error controlling {device_name or 'unknown device'}: {e}")
        raise

async def handle_action_over_devices(action, request_data, *args, **kwargs):
    all_devices = request_data.get('all', False)
    device_name = request_data.get('device')

    kwargs['nowait'] = kwargs.get('nowait',True)

    if not all_devices and not device_name:
        return jsonify({"status": "error", "message": "device name must be provided"}), 400

    tasks = []
    for device in devices:
        if device.get('name') == device_name or all_devices:
            tasks.append(asyncio.create_task(control_device(device, action, *args, **kwargs)))

    if tasks:
        return jsonify({"status": "success", "message": f"Devices {action} executed."})

    return jsonify({"status": "error", "message": f"Device {device_name} not found"}), 404

def parse_audio(audio_data, sample_rate, freq_range):
    n = len(audio_data)
    if n == 0:
        return (0, 0, 0)

    fft_data = np.fft.fft(audio_data)
    fft_abs = np.abs(fft_data[:n // 2])
    frequencies = np.fft.fftfreq(n, 1 / sample_rate)[:n // 2]

    freq_mask = np.logical_and(frequencies >= freq_range[0], frequencies <= freq_range[1])
    freq_range_values = fft_abs[freq_mask]

    if not freq_range_values.size:
        return (0, 0, 0)

    dominant_frequency_index = np.argmax(freq_range_values)
    dominant_frequency = frequencies[freq_mask][dominant_frequency_index]
    amplitude = freq_range_values[dominant_frequency_index]

    h = int((dominant_frequency / freq_range[1]) * 360)
    s = 1000 #int(min(amplitude / 10000, 1.0) * 1000)
    v = 1000 #int(min(amplitude / 5000, 1.0) * 1000)

    return h, s, v

@app.route('/list', methods=['GET'])
async def device_list():
    return jsonify([{ 'name': d.get('name'), 'id': d['id'], 'ip': d['ip'], 'version': d["ver"] } for d in devices])

@app.route('/turn_on', methods=['POST'])
async def turn_on():
    request_data = await request.get_json()
    return await handle_action_over_devices('turn_on', request_data)

@app.route('/turn_off', methods=['POST'])
async def turn_off():
    request_data = await request.get_json()
    return await handle_action_over_devices('turn_off', request_data)

@app.route('/set_mode', methods=['POST'])
async def set_mode():
    request_data = await request.get_json()
    mode = request_data.get('mode')
    return await handle_action_over_devices('set_mode', request_data, mode)

@app.route('/set_brightness', methods=['POST'])
async def set_brightness():
    request_data = await request.get_json()
    brightness = request_data.get('brightness')
    return await handle_action_over_devices('set_brightness', request_data, brightness)

@app.route('/set_temperature', methods=['POST'])
async def set_temperature():
    request_data = await request.get_json()
    temperature = request_data.get('temperature')
    return await handle_action_over_devices('set_colourtemp', request_data, temperature)

@app.route('/set_color', methods=['POST'])
async def set_color():
    request_data = await request.get_json()
    color_input = request_data.get('color')
    r, g, b = Color(color_input).rgb
    rgb = int(255 * r), int(255 * g), int(255 * b)
    return await handle_action_over_devices('set_colour', request_data, *rgb)

@app.route('/music', methods=['POST'])
async def music():
    global audio_tasks  # Ensure global scope

    request_data = await request.get_json()
    all_devices = request_data.get('all', False)
    stop_signal = request_data.get('stop', False)
    device_name = request_data.get('device')
    min_freq, max_freq = request_data.get('frequency_range', (10, 20000)) or (10, 20000)

    if not all_devices and not device_name:
        return jsonify({"status": "error", "message": "device must be provided"}), 400

    selected_devices = [d for d in devices if all_devices or d.get('name') == device_name]

    if not selected_devices:
        return jsonify({"status": "error", "message": "No matching devices found"}), 404

    # Stop existing tasks for selected devices before starting new ones
    tasks_to_stop = [task for task in audio_tasks if task.get_name() in {d['name'] for d in selected_devices}]
    for task in tasks_to_stop:
        task.cancel()
    await asyncio.gather(*tasks_to_stop, return_exceptions=True)

    # Clean up stopped tasks
    audio_tasks = [task for task in audio_tasks if not task.cancelled()]

    # If stop signal is sent, return after stopping
    if stop_signal:
        return jsonify({"status": "success", "message": "Stopped selected devices"}), 200

    # Start new music mode tasks
    step = (max_freq - min_freq) // len(selected_devices)
    frequency_ranges = [(min_freq + i * step, min_freq + (i + 1) * step) for i in range(len(selected_devices))]

    async def audio_task(device, freq_range):
        try:
            logging.info(f"Starting audio listener for {device['name']}.")
            process = await asyncio.create_subprocess_exec(
                'parec', '-d', AUDIO_TARGET, '--format=s16le', f'--rate={SAMPLE_RATE}',
                env={'XDG_RUNTIME_DIR': XDG_RUNTIME_DIR},
                stdout=asyncio.subprocess.PIPE
            )

            while True:
                stdout = await process.stdout.read(SAMPLE_RATE)
                if not stdout:
                    continue
                audio_data = np.frombuffer(stdout, dtype=np.int16).astype(float)
                hsv = parse_audio(audio_data, SAMPLE_RATE, freq_range)
                await control_device(device, 'set_hsv', *hsv)
        except asyncio.CancelledError:
            logging.info(f"Audio task for {device['name']} cancelled.")
        except Exception as e:
            logging.error(f"Error in audio processing for {device['name']}: {e}")
            await control_device(device, 'set_mode', 'white')
            await control_device(device, 'set_brightness', 1000)
            raise

    await handle_action_over_devices('set_mode', request_data, 'colour')

    new_tasks = [asyncio.create_task(audio_task(d, f), name=d['name']) for d, f in zip(selected_devices, frequency_ranges)]
    audio_tasks.extend(new_tasks)

    return jsonify({"status": "success", "message": "Music mode started"})

if __name__ == '__main__':
    asyncio.run(load_devices())
    logging.info("Daemon started")
    app.run(host='0.0.0.0', port=5000, debug=False)
